# 作用域和闭包

## 1.理解词法作用域和动态作用域

#### 作用域

作用域是指程序源代码中定义变量的区域。

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

#### 静态作用域与动态作用域

因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

让我们认真看个例子就能明白之间的区别：

```
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???
```

假设JavaScript采用静态作用域，让我们分析下执行过程：

执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。

假设JavaScript采用动态作用域，让我们分析下执行过程：

执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。

前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

#### 动态作用域

也许你会好奇什么语言是动态作用域？

bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 `bash ./scope.bash`，看看打印的值是多少。

```
value=1
function foo () {
    echo $value;
}
function bar () {
    local value=2;
    foo;
}
bar
```

## 2.理解`JavaScript`的作用域和作用域链

### 1.执行环境（execution context）

　　执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的变量对象（variable object），保存着该环境中定义的所有变量和函数。我们无法通过代码来访问变量对象，但是解析器在处理数据时会在后台使用到它。

　　执行环境有全局执行环境（也称全局环境）和函数执行环境之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们运行浏览器的时候会创建全局的执行环境，在调用函数时，会创建函数执行环境。

#### 1.1 全局执行环境

　　全局执行环境是最外围的一个执行环境，在web浏览器中，我们可以认为他是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。代码载入浏览器时，全局环境被创建，关闭网页或者关闭浏览时全局环境被销毁。

#### 1.2 函数执行环境

　　每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。

### 2.作用域、作用域链

#### 2.1 全局作用域（globe scope）和局部作用域（local scope）

　　**全局作用域**可以在代码中的任何地方都能被访问，例如：

```
1  var name1="haha";
2 function changName(){
3     var name2="xixi";
4     console.log(name1); // haha
5     console.log(name2);// xixi
6 } 
7 changName();
8 console.log(name1);//haha
9 console.log(name2);//Uncaught ReferenceError: name2 is not defined
```

　　其中，name1具有全局作用域，因此在第4行和第8行都会在控制台上输出 haha。name2定义在changName()函数内部，具有局部作用域，因此在第9行，解析器找不到变量name2，抛出错误。
　　另外，在函数中声明变量时，如果省略 var 操作符，那么声明的变量就是全局变量，拥有全局作用域，但是不推荐这种做法，因为在局部作用域中很难维护定义的全局变量。

　　再者，window对象的内置属性都拥有全局作用域。

 　　**局部作用域**一般只在固定的代码片段内可以访问得到，例如上述代码中的name2，只有在函数内部可以访问得到。

#### 2.2 作用域链（scope chain）

　　全局作用域和局部作用域中变量的访问权限，其实是由作用域链决定的。

　　每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。作用域链是函数被创建的作用域中**对象**的集合。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。

　　作用域链的最前端始终是当前执行的代码所在环境的变量对象（如果该环境是函数，则将其活动对象作为变量对象），下一个变量对象来自包含环境（包含当前还行环境的环境），下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。

　　标识符解析是沿着作用域一级一级的向上搜索标识符的过程。搜索过程始终是从作用域的前端逐地向后回溯，直到找到标识符（找不到，就会导致错误发生）。

例如：

```
 1 var name1 = "haha";
 2 function changeName(){
 3     var name2="xixi";
 4     function swapName(){
 5         console.log(name1);//haha
 6         console.log(name2);//xixi
 7         var tempName=name2;
 8         name2=name1;
 9         name1=tempName;
10         console.log(name1);//xixi11         console.log(name2);//haha
12         console.log(tempName);//xixi13     }
14     swapName();
15     console.log(name1);//haha
16     console.log(name2);//xixi
17     //console.log(tempName);抛出错误：Uncaught ReferenceError: tempName is not defined
18 }
19 changName();
20 console.log(name1);
21 //console.log(name2); 抛出错误：Uncaught ReferenceError: name2 is not defined
22 //console.log(tempName);抛出错误：Uncaught ReferenceError: tempName is not defined
```



 运行结果如下：

![img](https://images2015.cnblogs.com/blog/1013598/201609/1013598-20160909220825207-770260149.gif)

上述代码中，一共有三个执行环境：全局环境、changeName()的局部环境和 swapName() 的局部环境。所以，

　1.函数 swapName()的作用域链包含三个对象：**自己的变量对象----->changeName()局部环境的变量对象 ----->全局环境的变量对象**。

　2.函数changeName()的作用域包含两个对象：**自己的变量对象----->全局环境的变量对象。**

就上述程序中出现的变量和函数来讲（不考虑隐形变量）：

　1.swapName() 局部环境的变量对象中存放变量 tempName；

　2.changeName() 局部环境的变量对象中存放变量 name2 和 函数swapName()；

　3.全局环境的变量对象中存放变量 name1 、函数changeName();

 

　　在swapName()的执行环境中，在执行第5句代码时，解析器沿着函数 swapName()的作用域链一级级向后回溯查找变量 name1，直到在全局环境中找到变量 name1.并输出在控制台上。同样，在执行第6句代码时，解析器沿着函数 swapName()的作用域链一级级向后回溯，在函数changeName()的变量对象中发现变量 name2.通过代码对 name1 和 name2进行交换，并输出在控制台上，根据结果我们发现，这两个变量的值确实交换了。因此我们可以得出结论，**函数的局部环境可以访问函数作用域中的变量，也可以访问和操作父环境（包含环境）乃至全局环境中的变量。**

　　**在**changeName() 的执行环境中，执行第15行和第16行代码时，可以正确地输出  name1 和 name2 和两个变量的值（调用了函数swapName(),所以俩变量的值已相互交换），那是因为 name1 在changName()的父环境（全局环境）中， name2 在他自己的局部环境中，即 name1 和 name2 都在其作用域链上。但当执行第17行代码是发生错误 tempName is not defined。因为解析器沿着 函数changeName()的作用域链一级级的查找 变量 tempName时，并不能找到该变量的存在（变量 tempName不在其作用域链上），所以抛出错误。因此，我们可以得出结论：**父环境只能访问其包含环境和自己环境中的变量和函数，不能访问其子环境中的变量和函数。**

　　同理，在全局环境中，其变量对象中只存放变量 name1 、函数changeName();  解析器只能访问变量 name1 和函数 changeName(), 而不能访问和操作 函数 changeName() 和函数 swapName() 中定义的变量或者函数。因此，在执行第21行和第22行代码时抛出变量没有定义的错误。所以说，**全局环境只能访问全局环境中的变量和函数，不能直接访问局部环境中的任何数据。**

　　其实，我们可以把作用域链想象成这样（里面的能访问外面的，外面的不能访问里面的，图为参考）： 

　　![img](https://images2015.cnblogs.com/blog/1013598/201609/1013598-20160910103037879-1633973943.gif)

作用域链相关知识的总结：

1.执行环境决定了变量的生命周期，以及哪部分代码可以访问其中变量

2，执行环境有全局执行环境（全局环境）和局部执行环境之分。

3.每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链

4.函数的局部环境可以访问函数作用域中的变量和函数，也可以访问其父环境，乃至全局环境中的变量和环境。

5.全局环境只能访问全局环境中定义的变量和函数，不能直接访问局部环境中的任何数据。

6.变量的执行环境有助于确定应该合适释放内存。

### 3.提升（hoisting）

提升有变量提升和函数提升之分，下面我们依次介绍他们。

#### 3.1 变量提升（variable hoisting）

请看一下代码：

```
1  var name="haha";
2  function changeName(){
3      console.log(name);
4      var name="xixi";
5  }
6  changeName();
7  console.log(name);
```

大家认为第6行和第7行代码输出的结果应该是什么？好了，答案是：输出结果结果分别是 **undefined** 和 **haha**。为什么是undefined？ 按照作用域链的思路思考，输出的结果应该是 haha或者xixi啊？ （当然大家都知道 xixi是不可能的，因为解析器在解析第3行代码时，还不知道第4行中的赋值内容）。

　　那我们先来分析一下代码 函数changeName() 的作用域链： 自己的变量对象 -----> 全局变量对象。解析器在函数执行环境中发现变量 name，因此不会再向全局环境的变量对象中寻找。但是大家要注意的是，解析器在解析第3句代码时，还不知道变量name的值，也就是说只知道有变量name，但是不知道它具体的值（因为还没有执行第4句代码），因此输出是 undefined，第7行输出haha大家应该都理解把（作用域问题）。所以上述代码可以写成下面的形式：

```
1   var name="haha";
2   function changeName(){
3       var name;
4       console.log(name);
5       name="xixi";
6  }
7  changeName();
8  console.log(name);
```

这个现象就是**变量提升**！

　　变量提升，就是把变量提升到函数的顶部，需要注意的是，变量提升只是提升变量的声明，不会吧变量的值也提升上来！见上述代码，最常见的代码如下，函数example1()和函数example2()是等价的：

```
 1 function example1(){
 2     var a="haha";
 3     var b="xixi";
 4     var c="heihei";
 5 }
 6 
 7 
 8 function example2(){
 9     var a,b,c;
10     a="haha";
11     b="xixi";
12     c="heihei";
13 }
```

#### 3.2 函数提升（）

　　函数提升就是把函数提升到前面。

　　在JavaScript中函数的创建方式有三种：函数声明（静态的，像函数example1()的形式）、函数表达式（函数字面量）、函数构造法（动态的，匿名的）。函数表达式的形式如下：

```
1 var func1 = function(n1,n2){
2     //function body;
3 };
```

函数构造法构造函数的形式如下：

```
 var func2 = new Function("para1","para2",...,"function body");    
```

在这里需要说明的是：只有函数声明形式才能被提升！例如：

```
//函数声明
function myTest1(){ 
    func(); 
    function func(){ 
        console.log("我可以被提升"); 
    } 
} 
myTest1();

//函数表达式
function myTest2(){ 
    func(); 
    var func = function(){ 
        console.log("我不能被提升"); 
    } 
} 
myTest2();
```

控制台显示结果如下：

![img](https://images2015.cnblogs.com/blog/1013598/201609/1013598-20160911203525698-779117690.gif)

## 3.理解`JavaScript`的执行上下文栈，可以应用堆栈信息快速定位问题

### 一、执行上下文（Execution Context）

#### 1.什么是执行上下文

简而言之，执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行

#### 2.执行上下文的类型

执行上下文总共有三种类型：

- 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
- 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
- Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。

### 二、执行上下文的生命周期

执行上下文的生命周期包括三个阶段：**创建阶段→执行阶段→回收阶段**，本文重点介绍创建阶段。

#### 1.创建阶段

当函数被调用，但未执行任何其内部代码之前，会做以下三件事：

- 创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。下文会详细说明。
- 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
- 确定this指向：包括多种情况，下文会详细说明

在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。

另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。

#### 2.执行阶段

执行变量赋值、代码执行

#### 3.回收阶段

执行上下文出栈等待虚拟机回收执行上下文

### 三、变量提升和this指向的细节

#### 1.变量声明提升

大部分编程语言都是先声明变量再使用，但在JS中，事情有些不一样：

```
console.log(a)// undefined
var a = 10
```

上述代码正常输出`undefined`而不是报错`Uncaught ReferenceError: a is not defined`,这是因为声明提升（hoisting），相当于如下代码：

```
var a; //声明 默认值是undefined “准备工作”
console.log(a);
a=10; //赋值
```

#### 2.函数声明提升

我们都知道，创建一个函数的方法有两种，一种是通过函数声明`function foo(){}`
另一种是通过函数表达式`var foo = function(){}` ,那这两种在函数提升有什么区别呢？

```
console.log(f1) // function f1(){}
function f1() {} // 函数声明
console.log(f2) // undefined
var f2 = function() {} // 函数表达式
```

接下来我们通过一个例子来说明这个问题：

```
function test() {
    foo(); // Uncaught TypeError "foo is not a function"
    bar(); // "this will run!"
    var foo = function () { // function expression assigned to local variable 'foo'
        alert("this won't run!");
    }
    function bar() { // function declaration, given the name 'bar'
        alert("this will run!");
    }
}
test();
```

在上面的例子中，foo()调用的时候报错了，而bar能够正常调用。

我们前面说过变量和函数都会上升，遇到函数表达式 `var foo = function(){}`时，首先会将`var foo`上升到函数体顶部，然而此时的foo的值为undefined,所以执行`foo()`报错。

而对于函数`bar()`, 则是提升了整个函数，所以`bar()`才能够顺利执行。

有个细节必须注意：**当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。**

```
alert(a);//输出：function a(){ alert('我是函数') }
function a(){ alert('我是函数') }//
var a = '我是变量';
alert(a);   //输出：'我是变量'
```

function声明的优先级比var声明高，也就意味着当两个同名变量同时被function和var声明时，function声明会覆盖var声明

这代码等效于：

```
function a(){alert('我是函数')} 
var a;    //hoisting
alert(a);    //输出：function a(){ alert('我是函数') }
a = '我是变量';//赋值
alert(a);   //输出：'我是变量'
```

最后我们看个复杂点的例子：

```
function test(arg){
    // 1. 形参 arg 是 "hi"
    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function
    console.log(arg);  
    var arg = 'hello'; // 3.var arg 变量声明被忽略， arg = 'hello'被执行
    function arg(){
    console.log('hello world') 
    }
    console.log(arg);  
}
test('hi');
/* 输出：
function arg(){
    console.log('hello world') 
    }
hello 
*/
```

这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：

- 如果有形参，先给形参赋值
- 进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，**但是可以重新赋值**
- 私有作用域中的代码从上到下执行

#### 3.确定this的指向

先搞明白一个很重要的概念 —— **this的值是在执行的时候才能确认，定义的时候不能确认！** 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：

```
// 情况1
function foo() {
  console.log(this.a) //1
}
var a = 1
foo()

// 情况2
function fn(){
  console.log(this);
}
var obj={fn:fn};
obj.fn(); //this->obj

// 情况3
function CreateJsPerson(name,age){
//this是当前类的一个实例p1
this.name=name; //=>p1.name=name
this.age=age; //=>p1.age=age
}
var p1=new CreateJsPerson("尹华芝",48);

// 情况4
function add(c, d){
  return this.a + this.b + c + d;
}
var o = {a:1, b:3};
add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34

// 情况5
<button id="btn1">箭头函数this</button>
<script type="text/javascript">   
    let btn1 = document.getElementById('btn1');
    let obj = {
        name: 'kobe',
        age: 39,
        getName: function () {
            btn1.onclick = () => {
                console.log(this);//obj
            };
        }
    };
    obj.getName();
</script>
```

接下来我们逐一解释上面几种情况

- 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window
- 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象
- 在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例
- call、apply和bind：this 是第一个参数
- 箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。

![img](https://segmentfault.com/img/remote/1460000018550121?w=602&h=426)

#### 四、执行上下文栈（Execution Context Stack）

函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？

JavaScript 引擎创建了执行上下文栈来管理执行上下文。**可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则**。

![img](https://segmentfault.com/img/remote/1460000018550122?w=486&h=238)

从上面的流程图，我们需要记住几个关键点：

- JavaScript执行在单线程上，所有的代码都是排队执行。
- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的JS执行引擎总是访问栈顶的执行上下文。
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。

我们再来看个例子：

```
var color = 'blue';
function changeColor() {
    var anotherColor = 'red';
    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
    }
    swapColors();
}
changeColor();
```

上述代码运行按照如下步骤：

- 当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈
- 调用 changeColor函数时，此时changeColor函数内部代码还未执行，js执行引擎立即创建一个changeColor的执行上下文（简称EC），然后把这执行上下文压入到执行栈（简称ECStack）中。
- 执行changeColor函数过程中，调用swapColors函数，同样地，swapColors函数执行之前也创建了一个swapColors的执行上下文，并压入到执行栈中。
- swapColors函数执行完成，swapColors函数的执行上下文出栈，并且被销毁。
- changeColor函数执行完成，changeColor函数的执行上下文出栈，并且被销毁。

![img](https://segmentfault.com/img/remote/1460000018550123?w=1180&h=320)

## 4.`this`的原理以及几种不同使用场景的取值

#### 情况一：全局 & 调用普通函数
在全局环境中，this 永远指向 window。

```
console.log(this === window);     //true
```


普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。

```
var x = 10;
function foo(){
    console.log(this);     //Window
    console.log(this.x);   //10
}
foo();
```


#### 情况二：构造函数
所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。

情况二：构造函数
所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。

```
function Foo(){
    this.x = 10;
    console.log(this);    //Foo {x:10}
}
var foo = new Foo();
console.log(foo.x);      //10
```


上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。

但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。

```
function Foo(){
    this.x = 10;
    console.log(this);    //Window
}
var foo = Foo();
```


#### 情况三：对象方法
如果函数作为对象的方法时，方法中的 this 指向该对象。

```
var obj = {
    x: 10,
    foo: function () {
        console.log(this);        //Object
        console.log(this.x);      //10
    }
};
obj.foo();
```


注意：若是在对象方法中定义函数，那么情况就不同了。

注意：若是在对象方法中定义函数，那么情况就不同了。

```
var obj = {
    x: 10,
    foo: function () {
        function f(){
            console.log(this);      //Window
            console.log(this.x);    //undefined
        }
        f();
    }
}
obj.foo();
```


可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。

可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。

在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。

```
var obj = {
    x: 10,
    foo: function () {
        var self = this;
        function f(){
            console.log(self);      //{x: 10}
            console.log(self.x);    //10
        }
        f();
    }
}
obj.foo();
```


如果 foo 函数不作为对象方法被调用：

如果 foo 函数不作为对象方法被调用：

```
var obj = {
    x: 10,
    foo: function () {
        console.log(this);       //Window
        console.log(this.x);     //undefined
    }
};
var fn = obj.foo;
fn();
```


obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。

obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。

#### 情况四：构造函数 prototype 属性
```
function Foo(){
    this.x = 10;
}
Foo.prototype.getX = function () {
    console.log(this);        //Foo {x: 10, getX: function}
    console.log(this.x);      //10
}
var foo = new Foo();
foo.getX();
```


在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。
