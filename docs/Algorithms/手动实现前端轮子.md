# 手动实现前端轮子

## 1.手动实现`call、apply、bind`

#### 1.手动实现call

```js

Function.prototype.myCall = function(object) {
	let obj = object || window;	// 如果没有传this参数，this将指向window
	obj.fn = this;				// 获取函数本身，此时调用call方法的函数已经是传进来的对象的一个属性，也就是说函数的this已经指向传进来的对象
	let arg = [...arguments].slice(1);	// 获取第二个及后面的所有参数(arg是一个数组)
	let result = obj.fn(...arg);
	return result
}
```

#### 2.手动实现apply

```js
Function.prototype.myApply = function(object) {
	let obj = object || window;	// 如果没有传this参数，this将指向window
	obj.fn = this;				// 获取函数本身，此时调用call方法的函数已经是传进来的对象的一个属性，也就是说函数的this已经指向传进来的对象
	let arg = [...arguments].slice(1);	// 获取第二个及后面的所有参数(arg是一个数组)
	let result = obj.fn(arg);    // 这里不要将数组打散，而是将整个数组传进去
	return result
}
```

#### 3.手动实现bind

```js

Function.prototype.testBind = function(object){
          var that = this,
              args = Array.prototype.slice.call(arguments,1),
              bound = function(){
                    return that.apply(this instanceof fNOP?this:object||window,
                         args.concat.apply(Array.from(arguments)));
          };
        //创建一个中转函数fNOP，让bound间接继承目标函数的原型
          var fNOP =  function(){};
          fNOP.prototype= that.prototype;   
          bound.prototype= new fNOP();  
          return bound;
}
```



## 2.手动实现符合`Promise/A+`规范的`Promise`、手动实现`async await`

#### Promise/A+规范



## 3.手写一个`EventEmitter`实现事件发布、订阅

#### 发布

```js
// 发布订阅模式
class EventEmitter {
  constructor() {
    // 事件对象，存放订阅的名字和事件  如:  { click: [ handle1, handle2 ]  }
    this.events = {}
  }
  // 订阅事件的方法
  on(eventName, callback) {
    if (!this.events[eventName]) {
      // 一个名字可以订阅多个事件函数
      this.events[eventName] = [callback]
    } else {
      // 存在则push到指定数组的尾部保存
      this.events[eventName].push(callback)
    }
  }
  // 触发事件的方法
  emit(eventName, ...rest) {
    // 遍历执行所有订阅的事件
    this.events[eventName] &&
      this.events[eventName].forEach(f => f.apply(this, rest))
  }
  // 移除订阅事件
  remove(eventName, callback) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(f => f != callback)
    }
  }
  // 只执行一次订阅的事件，然后移除
  once(eventName, callback) {
    // 绑定的时fn, 执行的时候会触发fn函数
    const fn = () => {
      callback() // fn函数中调用原有的callback
      this.remove(eventName, fn) // 删除fn, 再次执行的时候之后执行一次
    }
    this.on(eventName, fn)
  }
}
```

#### 订阅使用

```js
const event = new EventEmitter()

const handle = (...pyload) => console.log(pyload)

event.on('click', handle)

event.emit('click', 100, 200, 300, 100)

event.remove('click', handle)

event.once('dbclick', function() {
  console.log('click')
})

event.emit('dbclick', 100)
```



## 4.可以说出两种实现双向绑定的方案、可以手动实现

```

```



## 5.手写`JSON.stringify`、`JSON.parse`

#### JSON.stringify()

```js
function jsonstringify(obj){
　　let type = typeof obj;
　　if(type !== 'object'){
　　　　if(/string|undefined|function/.test(type)){
　　　　　　obj = '"' + obj +'"'
　　　　}
　　　　return String(obj)
　　}else{
　　　　let arr = Array.isArray(obj);
　　　　let json =[];
　　　　for(let i in obj){
　　　　　　let j = obj[i];
　　　　　　let type = typeof j
　　　　　　if(/string|undefined|function/.test(type)){
　　　　　　　　j = '"' + j +'"'
　　　　　　}else if(type == 'object'){
　　　　　　　　j = jsonstringify(j)
　　　　　　}
　　　　　　json.push((arr ? "" : '"' + i + '":') + String(j));
　　　　}
　　　　return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}")
　　}
}
```

#### JSON.parse

```js

```



## 6.手写一个模版引擎，并能解释其中原理

```js
//例1
var data = {
    name: 'ruoyu',
    addr: 'Hunger Valley'
};
var tpl = 'Hello, my name is  {{name}}. I am in {{addr}}.';

var reg=/{{[a-zA-Z_$][a-zA-Z0-9_.]*}}/g;
var newStr = tpl.replace(reg,function(raw,key,offset,string){
    return data[key]||raw;
})//这样就是一个简单的模板引擎。

//例2
var data={
    name: 'ruoyu',
    addr: 'Hunger Valley',
    friend: {
        name: 'hunger',
        car: {
            color: 'white'
        }
    }
}
var tpl = 'Hello, my name is  {{name}}. I am in {{age}},I have a friend {{friend.name}},he has a {{friend.car.color}} car'

var reg=/{{[a-zA-Z_$][a-zA-Z0-9_.]*}}/g;
var newStr = tpl.replace(reg,function(raw,key,offset,string){
    var paths=key.split('.');
    var lookup=data;
    while(paths.length>0){
        lookup=lookup[paths.shift()];
    }
    return lookup||raw;
})

```



## 7.手写`懒加载`、`下拉刷新`、`上拉加载`、`预加载`等效果

#### 懒加载

```


```

